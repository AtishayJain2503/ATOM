# -*- coding: utf-8 -*-
"""efforts.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lVggcj0Fr_dWswpwp9fqsDoZdNdaszj5

Hurst Exponent With Momentum
"""

def hurst_f(input_ts, lags_to_test=20):
            # interpretation of return value
            # hurst < 0.5 - input_ts is mean reverting
            # hurst = 0.5 - input_ts is effectively random/geometric brownian motion
            # hurst > 0.5 - input_ts is trending
            tau = []
            lagvec = []
            #  Step through the different lags
            for lag in range(2, lags_to_test):
                #  produce price difference with lag
                pp = np.subtract(input_ts[lag:].values, input_ts[:-lag].values)
                #  Write the different lags into a vector
                lagvec.append(lag)
                #  Calculate the variance of the differnce vector
                tau.append(np.sqrt(np.std(pp)))
            #  linear fit to double-log graph (gives power)
            m = np.polyfit(np.log10(lagvec), np.log10(tau), 1)
            # calculate hurst
            hurst = m[0]*2
            print(hurst)
            return hurst

        mom10Data = lookbackInstrumentFeatures.getFeatureDf('mom_10')
        mom30Data = lookbackInstrumentFeatures.getFeatureDf('mom_30')
        ma90Data = lookbackInstrumentFeatures.getFeatureDf('ma_90')

        if len(ma90Data.index)>20:
            mom30 = mom30Data.iloc[-1]
            mom10 = mom10Data.iloc[-1]
            ma90 = ma90Data.iloc[-1]

            # Calculate Hurst Exponent
            hurst = ma90Data.apply(hurst_f, axis=0)

            predictions[(hurst > 0.5) & (mom30 > 0) & (mom10 > 0)] = 1

            predictions[(hurst > 0.5) & (mom30 <= 0) & (mom10 <= 0)] = 0

            predictions[(hurst > 0.5) & (mom30 > 0) & (mom10 <= 0)] = 0.5

            predictions[(hurst > 0.5) & (mom30 <= 0) & (mom10 > 0)] = 0.5


            predictions[hurst <= 0.5] = 0.5
        else:

            predictions.values[:] = 0.5
        return predictions

    def updateCount(self):
        self.count = self.count + 1

"""Baysean Interferance used with candlestick Patterns"""

import pandas as pd

def apply_trading_strategy(df):
    # Helper Functions
    def macd(data):
        data['MACD'] = data['Close'].ewm(span=12, adjust=False).mean() - data['Close'].ewm(span=28, adjust=False).mean()
        data['Signal_MACD'] = data['MACD'].ewm(span=9, adjust=False).mean()
        return data

    def detect_doji(row):
        if abs(row['Close'] - row['Open']) / (row['High'] - row['Low']) < 0.2:
            return "Doji"
        else:
            return "None"

    def detect_engulfing(data):
        data['Engulfing'] = 'None'
        for i in range(1, len(data)):
            prev, current = data.iloc[i-1], data.iloc[i]
            if (prev['Close'] < prev['Open'] and
                current['Close'] > current['Open'] and
                current['Close'] > prev['Open'] and
                current['Open'] < prev['Close']):
                data.at[i, 'Engulfing'] = 'Bullish'
            elif (prev['Close'] > prev['Open'] and
                  current['Close'] < current['Open'] and
                  current['Close'] < prev['Open'] and
                  current['Open'] > prev['Close']):
                data.at[i, 'Engulfing'] = 'Bearish'
        return data

    def trend(row):
        if row['SMA_10'] > row['SMA_30']:
            return "Uptrend"
        elif row['SMA_10'] < row['SMA_30']:
            return "Downtrend"
        else:
            return "None"

    def bayesian_strategy(pattern, trend, P_up, P_down, P_doji_given_up, P_doji_given_down):
        if pattern == "Doji":
            if trend == "Uptrend":
                P_doji_given_up = 0.6
                P_doji_given_down = 0.4
            elif trend == "Downtrend":
                P_doji_given_up = 0.4
                P_doji_given_down = 0.6
            elif trend == "None":
                P_doji_given_up = 0.5
                P_doji_given_down = 0.5
        else:
            P_doji_given_up = 0
            P_doji_given_down = 0

        P_doji = (P_doji_given_up * P_up) + (P_doji_given_down * P_down)
        P_up_given_doji = (P_doji_given_up * P_up) / P_doji if P_doji > 0 else 0
        P_down_given_doji = (P_doji_given_down * P_down) / P_doji if P_doji > 0 else 0

        return P_up_given_doji, P_down_given_doji

    # Calculate MACD
    df = macd(df)

    # Calculate SMA for trend
    df['SMA_10'] = df['Close'].rolling(window=10).mean()
    df['SMA_30'] = df['Close'].rolling(window=30).mean()

    # Detect Doji and Engulfing patterns
    df['pattern'] = df.apply(detect_doji, axis=1)
    df = detect_engulfing(df)

    # Calculate trend
    df['trend'] = df.apply(trend, axis=1)

    # Bayesian Inference Parameters
    P_up = 0.5
    P_down = 0.5
    P_doji_given_up = 0.6
    P_doji_given_down = 0.4
    buy_threshold = 0.7
    sell_threshold = 0.7

    signals = []

    for index, row in df.iterrows():
        pattern = row['pattern']
        trend = row['trend']
        engulfing = row['Engulfing']

        # Calculate Bayesian probabilities
        P_up_given_doji, P_down_given_doji = bayesian_strategy(pattern, trend, P_up, P_down, P_doji_given_up, P_doji_given_down)

        if (row['MACD'] < row['Signal_MACD']) and (P_down_given_doji > sell_threshold or engulfing == 'Bearish'):
            signals.append(-1)  # Sell
        elif (row['MACD'] > row['Signal_MACD']) and (P_up_given_doji > buy_threshold or engulfing == 'Bullish'):
            signals.append(1)   # Buy
        else:
            signals.append(0)   # Hold

    # Add signals to DataFrame
    df['signals'] = signals

    return df

# Example usage
# df = pd.read_csv('your_data.csv')  # Load your DataFrame
df = apply_trading_strategy(df)
print(df[['signals']].value_counts())

"""Capital Reallocation with two strategies

"""

#first strategy by using fibonacci retracement levels, sma and rsi indicators
high_price = btc['High'].max()
low_price = btc['Low'].min()

diff = high_price - low_price
levels = {
    '0%': high_price,
    '23.6%': high_price - 0.236 * diff,
    '38.2%': high_price - 0.382 * diff,
    '50%': high_price - 0.5 * diff,
    '61.8%': high_price - 0.618 * diff,
    '76.4%': high_price - 0.764 * diff,
    '100%': low_price
}
plt.figure(figsize=(14, 7))
plt.plot(btc['Close'], label='Close Price')
for level, price in levels.items():
    plt.axhline(price, linestyle='--', alpha=0.5, label=f'Fibonacci {level}')
plt.legend()
plt.title('BTC Price with Fibonacci Retracement Levels')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.show()





#sma
btc['SMA50'] = btc['Close'].rolling(window=50).mean()
btc['SMA100'] = btc['Close'].rolling(window=100).mean()

#RSI
window_length = 14
close_diff = btc['Close'].diff()
gain = close_diff.where(close_diff > 0, 0).rolling(window=window_length).mean()
loss = (-close_diff.where(close_diff < 0, 0)).rolling(window=window_length).mean()
rsi = 100 - 100 / (1 + (gain / loss))
btc['RSI'] = rsi.fillna(50)

initial_balance = 10000
balance = initial_balance
position = 0

buy_level = levels['61.8%']
sell_level = levels['38.2%']
stop_loss_level = levels['76.4%']
take_profit_level = levels['0%']

rsi_overbought = 66
rsi_oversold = 28

trades = []

btc['Signal_A'] = 0
btc['Total_Equity'] = 0

for i in range(1, len(btc)):
    price_today = btc['Close'].iloc[i]
    price_yesterday = btc['Close'].iloc[i - 1]
    sma50 = btc['SMA50'].iloc[i]
    sma100 = btc['SMA100'].iloc[i]
    rsi = btc['RSI'].iloc[i]

    if position == 0 and price_today > sma100:
        if price_today <= buy_level or rsi <= rsi_oversold:
            position = balance / price_today
            balance -= position * price_today
            trades.append(('Buy', price_today))
            btc.at[btc.index[i], 'Signal_A'] = 1
    elif position > 0 and price_today < sma100:
        if price_today >= sell_level or rsi >= rsi_overbought:
            balance += position * price_today
            position = 0
            trades.append(('Sell', price_today))
            btc.at[btc.index[i], 'Signal_A'] = -1

    elif price_today <= stop_loss_level and position > 0:
        balance += position * price_today
        position = 0
        trades.append(('Stop-loss', price_today))
        btc.at[btc.index[i], 'Signal_A'] = -1

    elif price_today >= take_profit_level and position > 0:
        balance += position * price_today
        position = 0
        trades.append(('Take-profit', price_today))
        btc.at[btc.index[i], 'Signal_A'] = -1

    total_equity = balance + position * price_today
    btc.at[btc.index[i], 'Total_Equity'] = total_equity
btc.at[btc.index[0], 'Total_Equity'] = initial_balance

final_balance = balance + position * btc['Close'].iloc[-1]
print(f'Initial Balance: ${initial_balance:.2f}')
print(f'Final Balance: ${final_balance:.2f}')
print('Trade History:')
for trade in trades:
    print(trade)






def calculate_ichimoku(btc):

    high_9 = btc['High'].rolling(window=9).max()
    low_9 = btc['Low'].rolling(window=9).min()
    btc['Tenkan_sen'] = (high_9 + low_9) / 2

    high_26 = btc['High'].rolling(window=26).max()
    low_26 = btc['Low'].rolling(window=26).min()
    btc['Kijun_sen'] = (high_26 + low_26) / 2

    btc['Senkou_span_A'] = ((btc['Tenkan_sen'] + btc['Kijun_sen']) / 2).shift(26)

    high_52 = btc['High'].rolling(window=52).max()
    low_52 = btc['Low'].rolling(window=52).min()
    btc['Senkou_span_B'] = ((high_52 + low_52) / 2).shift(26)

    btc['Chikou_span'] = btc['Close'].shift(-26)

    return btc

def calculate_parabolic_sar(data, af=0.02, max_af=0.2):

    data['SAR'] = data['Close'].shift(1)
    data['EP'] = data['High']
    data['AF'] = af

    for i in range(2, len(data)):
        if data['Close'][i-1] > data['SAR'][i-1]:
            data['SAR'][i] = data['SAR'][i-1] + data['AF'][i-1] * (data['EP'][i-1] - data['SAR'][i-1])
            data['SAR'][i] = min(data['SAR'][i], data['Low'][i-1], data['Low'][i-2])
            if data['High'][i] > data['EP'][i-1]:
                data['EP'][i] = data['High'][i]
                data['AF'][i] = min(data['AF'][i-1] + af, max_af)
            else:
                data['EP'][i] = data['EP'][i-1]
                data['AF'][i] = data['AF'][i-1]
        else:
            data['SAR'][i] = data['SAR'][i-1] + data['AF'][i-1] * (data['EP'][i-1] - data['SAR'][i-1])
            data['SAR'][i] = max(data['SAR'][i], data['High'][i-1], data['High'][i-2])
            if data['Low'][i] < data['EP'][i-1]:
                data['EP'][i] = data['Low'][i]
                data['AF'][i] = min(data['AF'][i-1] + af, max_af)
            else:
                data['EP'][i] = data['EP'][i-1]
                data['AF'][i] = data['AF'][i-1]

    return data

def trading_signals(data, rsi_upper_threshold=70, rsi_lower_threshold=30):

    data['Signal'] = 0
    data['Signal'] = np.where(data['Close'] > data['SAR'], 1, data['Signal'])
    data['Signal'] = np.where(data['Close'] < data['SAR'], -1, data['Signal'])

    # Ichimoku Cloud conditions
    data['Above_Cloud'] = (data['Close'] > data[['Senkou_span_A', 'Senkou_span_B']].max(axis=1))
    data['Below_Cloud'] = (data['Close'] < data[['Senkou_span_A', 'Senkou_span_B']].min(axis=1))

    # RSI filter
    data['RSI_Filter'] = np.where(data['RSI'] > rsi_upper_threshold, 1,
                                  np.where(data['RSI'] < rsi_lower_threshold, -1, 0))

    # Adjust signals based on Ichimoku Cloud and RSI filter
    data['Signal_B'] = 0
    data['Signal_B'] = np.where((data['Signal'] == 1) & data['Above_Cloud'] & (data['RSI_Filter'] == 1), 1, data['Signal_B'])
    data['Signal_B'] = np.where((data['Signal'] == -1) & data['Below_Cloud'] & (data['RSI_Filter'] == -1), -1, data['Signal_B'])

    return data

def simulate_trading(data, initial_balance=10000):

    balance = initial_balance
    position = 0  # 1 for long, -1 for short, 0 for no position
    equity_curve = []
    entry_price = 0

    for index, row in data.iterrows():
        if row['Signal_B'] == 1 and position == 0:
            position = 1
            entry_price = row['Close']
            print(f"Enter long at {entry_price} on {index}")
        elif row['Signal_B'] == -1 and position == 0:
            position = -1
            entry_price = row['Close']
            print(f"Enter short at {entry_price} on {index}")
        elif row['Signal_B'] == -1 and position == 1:
            balance += (row['Close'] - entry_price)
            print(f"Exit long at {row['Close']} on {index}, Profit: {row['Close'] - entry_price}")
            position = 0
        elif row['Signal_B'] == 1 and position == -1:
            balance += (entry_price - row['Close'])
            print(f"Exit short at {row['Close']} on {index}, Profit: {entry_price - row['Close']}")
            position = 0
        equity_curve.append(balance + position * (row['Close'] - entry_price if position != 0 else 0))

    data['Equity'] = equity_curve
    final_balance = equity_curve[-1]

    return data, final_balance

btc = calculate_ichimoku(btc)

btc = calculate_parabolic_sar(btc)

btc = trading_signals(btc)

btc, final_balance = simulate_trading(btc)
print(f"Final Balance: ${final_balance:.2f}")




# Calculate daily returns
btc['return'] = btc['Close'].pct_change().fillna(0)

btc['strategy1_return'] = btc['Signal_A'] * btc['return']
btc['strategy2_return'] = btc['Signal_B'] * btc['return']

capital_strategy1 = 5000
capital_strategy2 = 5000

capital_strategy1_list = [capital_strategy1]
capital_strategy2_list = [capital_strategy2]

for i in range(1, len(btc)):

    capital_strategy1 *= (1 + btc.iloc[i]['strategy1_return'])
    capital_strategy2 *= (1 + btc.iloc[i]['strategy2_return'])


    if btc.iloc[i]['strategy1_return'] > 0 and btc.iloc[i]['strategy2_return'] > 0:
        if btc.iloc[i]['strategy1_return'] > btc.iloc[i]['strategy2_return']:
            transfer_amount = 0.05 * capital_strategy2
            capital_strategy1 += transfer_amount
            capital_strategy2 -= transfer_amount
        else:
            transfer_amount = 0.05 * capital_strategy1
            capital_strategy1 -= transfer_amount
            capital_strategy2 += transfer_amount
    elif btc.iloc[i]['strategy1_return'] < 0 and btc.iloc[i]['strategy2_return'] < 0:
        if btc.iloc[i]['strategy1_return'] < btc.iloc[i]['strategy2_return']:
            transfer_amount = 0.05 * capital_strategy1
            capital_strategy1 -= transfer_amount
            capital_strategy2 += transfer_amount
        else:
            transfer_amount = 0.05 * capital_strategy2
            capital_strategy1 += transfer_amount
            capital_strategy2 -= transfer_amount
    elif btc.iloc[i]['strategy1_return'] < 0 and btc.iloc[i]['strategy2_return'] > 0:
        transfer_amount = 0.05 * capital_strategy1
        capital_strategy1 -= transfer_amount
        capital_strategy2 += transfer_amount
    elif btc.iloc[i]['strategy1_return'] > 0 and btc.iloc[i]['strategy2_return'] < 0:
        transfer_amount = 0.05 * capital_strategy2
        capital_strategy1 += transfer_amount
        capital_strategy2 -= transfer_amount

    capital_strategy1_list.append(capital_strategy1)
    capital_strategy2_list.append(capital_strategy2)

btc['capital_strategy1'] = capital_strategy1_list
btc['capital_strategy2'] = capital_strategy2_list

btc['total_capital'] = btc['capital_strategy1'] + btc['capital_strategy2']

print(btc.total_capital.tail(50))

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import math
import warnings

warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.simplefilter(action='ignore', category=pd.errors.SettingWithCopyWarning)

# Download data
data = yf.download("BHARTIARTL.NS", '2017-01-01', '2022-01-01')

# Calculate daily return
data['daily_return'] = data['Adj Close'].pct_change()

# Heikin-Ashi calculation
def heikin_Ashi(data):
    data['Close_Ha'] = (data['Open'] + data['High'] + data['Close'] + data['Low']) / 4
    data['Open_Ha'] = (data['Open'].shift(1) + data['Close'].shift(1)) / 2
    data['High_Ha'] = data[['High', 'Close_Ha', 'Open_Ha']].max(axis=1)
    data['Low_Ha'] = data[['Low', 'Close_Ha', 'Open_Ha']].min(axis=1)
    return data

# Technical Indicators
def RSI(df, period=14):
    delta = df['Close_Ha'].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    df['RSI_Signal'] = np.where(rsi > 70, -1, np.where(rsi < 30, 1, 0))
    return rsi

def ROC(df, period=12):
    roc = ((df['Close_Ha'] - df['Close_Ha'].shift(period)) / df['Close_Ha'].shift(period)) * 100
    df['ROC_Signal'] = np.where(roc > 0, 1, -1)
    return roc

def CCI(df, period=20):
    tp = (df['High_Ha'] + df['Low_Ha'] + df['Close_Ha']) / 3
    sma = tp.rolling(window=period).mean()
    mad = tp.rolling(window=period).apply(lambda x: np.fabs(x - x.mean()).mean())
    cci = (tp - sma) / (0.015 * mad)
    df['CCI_Signal'] = np.where(cci > 100, -1, np.where(cci < -100, 1, 0))
    return cci

def CMO(df, period=14):
    delta = df['Close_Ha'].diff(1)
    gain = delta.where(delta > 0, 0).rolling(window=period).sum()
    loss = -delta.where(delta < 0, 0).rolling(window=period).sum()
    cmo = 100 * (gain - loss) / (gain + loss)
    df['CMO_Signal'] = np.where(cmo > 0, 1, -1)
    return cmo

def Momentum(df, period=10):
    momentum = df['Close_Ha'].diff(period)
    df['Momentum_Signal'] = np.where(momentum > 0, 1, -1)
    return momentum

# Apply Heikin-Ashi and calculate indicators
data = heikin_Ashi(data)
data['RSI'] = RSI(data)
data['ROC'] = ROC(data)
data['CCI'] = CCI(data)
data['CMO'] = CMO(data)
data['Momentum'] = Momentum(data)

data['signals'] = np.zeros(len(data))

# Apply the condition: if the sum of the signals is greater than 3, set 'Signals' to 1; if less than -2, set to -1
for i in range(len(data)):
    signal_sum = (data['RSI_Signal'].iloc[i] +
                  data['ROC_Signal'].iloc[i] +
                  data['CCI_Signal'].iloc[i] +
                  data['CMO_Signal'].iloc[i] +
                  data['Momentum_Signal'].iloc[i])

    if signal_sum > 2:
        data['signals'].iloc[i] = 1
    elif signal_sum < -2:
        data['signals'].iloc[i] = -1
    else:
        data['signals'].iloc[i] = 0

# calculate_atr(data, 14)

plt.figure(figsize=(14, 7))
plt.plot(data.index, data['Close'], label='Close Price', color='blue', alpha=0.5)
plt.scatter(data.index[data['signals'] == 1], data['Close'][data['signals'] == 1], marker='^', color='green', label='Long Signal', s=100, edgecolor='k')
plt.scatter(data.index[data['signals'] == -1], data['Close'][data['signals'] == -1], marker='v', color='red', label='Short Signal', s=100, edgecolor='k')
plt.title('Close Price with Long and Short Signals')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid()
plt.show()
length_long_signals = len(data['signals'][data['signals'] == 1])
length_short_signals = len(data['signals'][data['signals'] == -1])
print(f"Number of Long Signals: {length_long_signals}")
print(f"Number of Short Signals: {length_short_signals}")

"""# first of all we denoise the data and then we choose 5 momentum based indicators and if at least 3 out of 5 indicator are giving  signal of buy/sell ,acccordingly we proceeded

"""

def support_res(data):
    lookback = 10  # Number of days to look back for support and resistance

    # Calculate Support and Resistance levels
    data['Support'] = data['Low_Ha'].rolling(window=lookback).min()
    data['Resistance'] = data['High_Ha'].rolling(window=lookback).max()

    # Initialize a signal column with 0 (Hold)
    data['Signals'] = 0

    # Define Range Trading Strategy
    for i in range(lookback - 1, len(data)):
        if data['Close_Ha'].iloc[i] <= data['Support'].iloc[i] * 1.01:
            data['Signals'].iloc[i] = 1  # Buy signal (Price near support)
        elif data['Close_Ha'].iloc[i] >= data['Resistance'].iloc[i] / 1.01:
            data['Signals'].iloc[i] = -1  # Sell signal (Price near resistance)
        else:
            data['Signals'].iloc[i] = 0  # Hold signal

    return data


support_res(data)

length=len(data['Signals'][data['Signals']!=0])

"""#The strategy generates buy signals when the closing price is near the support level and sell signals when the closing price is near the resistance level, indicating potential price reversals.

"""

data['Sign'] = np.zeros(len(data))
for i in range(1,len(data)-1):
    if data['Open'].iloc[i]>data['High'].iloc[i-1] :
        data['Sign'].iloc[i]=1
    elif data['Open'].iloc[i]<data['Low'].iloc[i-1] :
        data['Sign'].iloc[i]=-1

    else:
         data['Sign'].iloc[i]=0


#Inside Bar Strategy (volatilaty)

for i in range(1,len(data)-1):
    if data['Low'].iloc[i]>data['Low'].iloc[i-1] and data['High'].iloc[i] < data['High'].iloc[i-1] :
        data['Sign'].iloc[i]=1
    elif data['Low'].iloc[i]>data['Low'].iloc[i-1] and data['High'].iloc[i] < data['High'].iloc[i-1] :
        data['Sign'].iloc[i]=-1

    else:
         data['Sign'].iloc[i]=0

"""#The strategy combines a momentum-based Greedy Candlestick pattern and an Inside Bar volatility pattern. It generates a buy or sell signal based on price movement relative to the previous candlestick's high and low levels.
#Greedy Candestick (momentum based)
"""

df=data.copy()
def calculate_huma(df, short_window=12, long_window=26, signal_window=9):
    df['hma_short'] = df['Close'].ewm(span=short_window, adjust=False).mean()
    df['hma_long'] = df['Close'].ewm(span=long_window, adjust=False).mean()
    df['huma'] = df['hma_short'] - df['hma_long']
    df['huma_line'] = df['huma'].ewm(span=signal_window, adjust=False).mean()
    return df

df = calculate_huma(df)

# Calculate Chaikin Volatility
def calculate_chaikin_volatility(df, ema_period=14):
    high_low_diff = df['High'] - df['Low']
    ema_diff = high_low_diff.ewm(span=ema_period, adjust=False).mean()
    chaikin_volatility = (ema_diff.diff() / ema_diff.shift(1)) * 100
    df['Chaikin_Volatility'] = chaikin_volatility
    return df

df = calculate_chaikin_volatility(df)

# Calculate MFI (Money Flow Index)
def calculate_mfi(df, period):
    tp = (df['High'] + df['Low'] + df['Close']) / 3
    mf = tp * df['Volume']
    pos_mf = mf.where(tp > tp.shift(1), 0).rolling(window=period).sum()
    neg_mf = mf.where(tp < tp.shift(1), 0).rolling(window=period).sum()
    mf_ratio = pos_mf / neg_mf
    return 100 - (100 / (1 + mf_ratio))

def dynamic_mfi(df):
    # Calculate both short-term and long-term MFI
    df['MFI_Short'] = calculate_mfi(df, period=9)
    df['MFI_Long'] = calculate_mfi(df, period=14)

    # Determine which MFI to use based on Chaikin Volatility
    mean_volatility = df['Chaikin_Volatility'].mean()
    df['MFI'] = np.where(df['Chaikin_Volatility'] > mean_volatility, df['MFI_Short'], df['MFI_Long'])

    return df

def calculate_ibs(df):

    ibs = (df['Close'] - df['Low']) / (df['High'] - df['Low'])
    return ibs

df['IBS'] = calculate_ibs(df)

df = dynamic_mfi(df)

# Calculate ADX (Average Directional Index)
def calculate_adx(df, period=14):
    df['TR'] = np.maximum(df['High'] - df['Low'],
                          np.maximum(abs(df['High'] - df['Close'].shift(1)),
                                     abs(df['Low'] - df['Close'].shift(1))))
    df['+DM'] = np.where((df['High'] - df['High'].shift(1)) > (df['Low'].shift(1) - df['Low']),
                         np.maximum(df['High'] - df['High'].shift(1), 0), 0)
    df['-DM'] = np.where((df['Low'].shift(1) - df['Low']) > (df['High'] - df['High'].shift(1)),
                         np.maximum(df['Low'].shift(1) - df['Low'], 0), 0)
    df['TR_smooth'] = df['TR'].rolling(window=period).mean()
    df['+DI'] = 100 * (df['+DM'].rolling(window=period).mean() / df['TR_smooth'])
    df['-DI'] = 100 * (df['-DM'].rolling(window=period).mean() / df['TR_smooth'])
    df['DX'] = 100 * abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI'])
    df['ADX'] = df['DX'].rolling(window=period).mean()
    return df

df = calculate_adx(df)

df['Buy_Signal'] = np.where((df['huma'] < df['huma_line']) & (df['MFI'] < 30) & (df['ADX'] > 25), 1, 0)
df['Sell_Signal'] = np.where((df['huma'] > df['huma_line']) & (df['MFI'] > 70) & (df['ADX'] > 25), -1, 0)

# Combine signals
df['signals'] = df['Buy_Signal'] + df['Sell_Signal']

"""# #This code implements a trading strategy by using several technical indicators:

# Huma Calculation: The code calculates a modified MACD (Huma) by subtracting a long-term exponential moving average (EMA) from a short-term EMA of the closing price. The difference is then smoothed to create a signal line (huma_line).

# Chaikin Volatility: It measures the difference between high and low prices, smoothed by an EMA. The rate of change of this difference is used to assess market volatility.

# Money Flow Index (MFI): The MFI is calculated for both short-term and long-term periods. The MFI uses price and volume to indicate buying or selling pressure. The strategy selects which MFI to use based on the Chaikin Volatility—higher volatility uses the short-term MFI, while lower volatility uses the long-term MFI.

# IBS (Inside Bar Strength): This measures the relative position of the closing price within the day’s high-low range, offering insight into price strength.

# ADX (Average Directional Index): ADX measures the strength of a trend by calculating the smoothed average of directional movement indicators (DI+ and DI-).

# Signal Generation:

# Buy Signal: Generated when the Huma is below its signal line, MFI is below 30 (indicating potential oversold conditions), and ADX is above 25 (indicating a strong trend).
# Sell Signal: Generated when the Huma is above its signal line, MFI is above 70 (indicating potential overbought conditions), and ADX is above 25.
# df.index = pd.to_datetime(df.index, utc=False)
"""

import pandas as pd
import numpy as np
data.rename(columns={'Open': 'open', 'High': 'high', 'Low': 'low', 'Close':'close' , 'Volume': 'volume'}, inplace=True)
# data.fillna(method='ffill', inplace=True)
def calculate_adx(data, period=14, adx_level=15):
    # Calculate True Range (TR)
    data['TR'] = np.maximum(data['high'] - data['low'],
                            np.maximum(np.abs(data['high'] - data['close'].shift(1)),
                                       np.abs(data['low'] - data['close'].shift(1))))

    # Calculate Directional Movement (+DM and -DM)
    data['+DM'] = np.where((data['high'] - data['high'].shift(1)) > (data['low'].shift(1) - data['low']),
                           np.maximum(data['high'] - data['high'].shift(1), 0), 0)
    data['-DM'] = np.where((data['low'].shift(1) - data['low']) > (data['high'] - data['high'].shift(1)),
                           np.maximum(data['low'].shift(1) - data['low'], 0), 0)

    # Smooth TR, +DM, and -DM
    data['Smoothed_TR'] = data['TR'].rolling(window=period).mean()
    data['Smoothed_+DM'] = data['+DM'].rolling(window=period).mean()
    data['Smoothed_-DM'] = data['-DM'].rolling(window=period).mean()

    # Calculate DI+ and DI-
    data['DI+'] = 100 * (data['Smoothed_+DM'] / data['Smoothed_TR'])
    data['DI-'] = 100 * (data['Smoothed_-DM'] / data['Smoothed_TR'])

    # Calculate DX and ADX
    data['DX'] = 100 * np.abs((data['DI+'] - data['DI-']) / (data['DI+'] + data['DI-']))
    data['ADX'] = data['DX'].rolling(window=period).mean()

    # Generate ADX buy/sell signals
    data['ADX_Buy'] = (data['DI-'] < data['DI+']) & (data['ADX'] > adx_level)
    data['ADX_Sell'] = (data['DI-'] > data['DI+']) & (data['ADX'] > adx_level)

    return data

def calculate_ema(data, span=200):
    data['EMA'] = data['close'].ewm(span=span, adjust=False).mean()
    data['Above_EMA'] = data['close'] > data['EMA']
    data['Below_EMA'] = data['close'] < data['EMA']
    return data

def calculate_macd(data):
    data['MACD_Fast'] = data['close'].ewm(span=12, adjust=False).mean()
    data['MACD_Slow'] = data['close'].ewm(span=26, adjust=False).mean()
    data['MACD_Line'] = data['MACD_Fast'] - data['MACD_Slow']
    data['MACD_Signal'] = data['MACD_Line'].ewm(span=9, adjust=False).mean()

    data['MACD_Buy'] = (data['MACD_Line'] < 0) & (data['MACD_Signal'] < 0) & (data['MACD_Line'] > data['MACD_Signal'])
    data['MACD_Sell'] = (data['MACD_Line'] > 0) & (data['MACD_Signal'] > 0) & (data['MACD_Line'] < data['MACD_Signal'])

    return data

def generate_signals(data):
    # Initialize signals column
    data['signals'] = 0

    # Buy Signal Condition
    buy_condition = (data['ADX_Buy'] & data['MACD_Buy'] & data['Above_EMA'])
    # Sell Signal Condition
    sell_condition = (data['ADX_Sell'] & data['MACD_Sell'] & data['Below_EMA'])

    # Assign signals based on conditions
    data.loc[buy_condition, 'signals'] = 1
    data.loc[sell_condition, 'signals'] = -1

    return data

# Apply all functions
data = calculate_adx(data, 14, 15)
data = calculate_ema(data, 200)
data = calculate_macd(data)
data = generate_signals(data)

# Print count of non-zero signals
print(len(data[data['signals'] != 0]))

pip install ta.trend

"""# This code implements a trading strategy that combines three technical indicators: ADX, EMA, and MACD. Here's a simple explanation:

# ADX Calculation: The ADX (Average Directional Index) is calculated to measure the strength of a trend. It also identifies whether the market is in a buying or selling condition based on directional movements (DI+ and DI-).

# EMA Calculation: The Exponential Moving Average (EMA) is computed over 200 periods to identify the overall market trend. The code checks if the price is above (indicating a bullish trend) or below (indicating a bearish trend) this EMA.

# MACD Calculation: The MACD (Moving Average Convergence Divergence) is calculated to detect momentum changes. It generates buy signals when the MACD line crosses above the signal line from below and sell signals when it crosses below the signal line from above.

# Signal Generation:

# Buy Signal: A buy signal is generated when the ADX indicates a strong trend, the MACD shows positive momentum, and the price is above the EMA.
# Sell Signal: A sell signal is generated when the ADX indicates a strong trend, the MACD shows negative momentum, and the price is below the EMA.
"""

import yfinance as yf
import pandas as pd
import numpy as np
from ta.trend import SMAIndicator, ADXIndicator
import matplotlib.pyplot as plt
import warnings
import scipy.stats as stats
import math
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.simplefilter(action='ignore', category=pd.errors.SettingWithCopyWarning)
# Function to calculate Heikin-Ashi candles
def heikin_ashi(data):
    data['Close_Ha'] = (data['Open'] + data['High'] + data['Close'] + data['Low']) / 4
    data['Open_Ha'] = (data['Open'].shift(1) + data['Close'].shift(1)) / 2
    data['High_Ha'] = data[['High', 'Close_Ha', 'Open_Ha']].max(axis=1)
    data['Low_Ha'] = data[['Low', 'Close_Ha', 'Open_Ha']].min(axis=1)
    return data

# Download historical data
df = yf.download("^NSEI", '2017-01-01', '2022-01-01')

# Calculate Heikin-Ashi candles
df = heikin_ashi(df)

# Calculate SMAs using Heikin-Ashi close prices
df['SMA10'] = SMAIndicator(df['Close_Ha'], window=10).sma_indicator()
df['SMA20'] = SMAIndicator(df['Close_Ha'], window=20).sma_indicator()
df['SMA50'] = SMAIndicator(df['Close_Ha'], window=50).sma_indicator()
df['SMA100'] = SMAIndicator(df['Close_Ha'], window=100).sma_indicator()
df['SMA200'] = SMAIndicator(df['Close_Ha'], window=200).sma_indicator()

# Calculate ADX using Heikin-Ashi high, low, and close prices
adx_indicator = ADXIndicator(df['High_Ha'], df['Low_Ha'], df['Close_Ha'], window=14)
df['ADX'] = adx_indicator.adx()

# Initialize signal column
df['signals'] = 0

# Generate signals based on conditions
for i in range(1, len(df)):
    if (df['SMA10'].iloc[i] > df['SMA20'].iloc[i] > df['SMA50'].iloc[i] > df['SMA100'].iloc[i] > df['SMA200'].iloc[i] and
        df['ADX'].iloc[i] > 20):
        if i >= 5 and all(df['SMA10'].iloc[i-j] > df['SMA20'].iloc[i-j] > df['SMA50'].iloc[i-j] > df['SMA100'].iloc[i-j] > df['SMA200'].iloc[i-j] for j in range(5)):
            df['signals'].iloc[i] = 1
    elif (df['SMA10'].iloc[i] < df['SMA20'].iloc[i] < df['SMA50'].iloc[i] < df['SMA100'].iloc[i] < df['SMA200'].iloc[i] and
          df['ADX'].iloc[i] > 20):
        if i >= 5 and all(df['SMA10'].iloc[i-j] < df['SMA20'].iloc[i-j] < df['SMA50'].iloc[i-j] < df['SMA100'].iloc[i-j] < df['SMA200'].iloc[i-j] for j in range(5)):
            df['signals'].iloc[i] = -1

# Display results
# print(df[['Close_Ha', 'SMA10', 'SMA20', 'SMA50', 'SMA100', 'SMA200', 'ADX', 'Sign']].tail(20))
x=len(df['signals'][df['signals']!=-1])
# Plotting for visualization (optional)
plt.figure(figsize=(14, 7))
plt.plot(df['Close_Ha'], label='Heikin-Ashi Close Price', color='gray')
plt.plot(df['SMA10'], label='SMA 10', color='blue')
plt.plot(df['SMA20'], label='SMA 20', color='green')
plt.plot(df['SMA50'], label='SMA 50', color='red')
plt.plot(df['SMA100'], label='SMA 100', color='purple')
plt.plot(df['SMA200'], label='SMA 200', color='orange')
plt.legend()
plt.show()

"""# This code is designed to generate trading signals using Heikin-Ashi candles and several Simple Moving Averages (SMAs), combined with the ADX (Average Directional Index) indicator. Here's a breakdown:

# Heikin-Ashi Calculation: The Heikin-Ashi candlesticks are calculated to smooth out price data and make trends easier to identify. The Heikin-Ashi close, open, high, and low prices are derived from the standard candlestick data.

# SMA Calculation: SMAs for 10, 20, 50, 100, and 200 periods are calculated using the Heikin-Ashi close prices. These SMAs help to identify trends over different time frames.

# ADX Calculation: The ADX indicator is calculated using the Heikin-Ashi high, low, and close prices. The ADX helps to measure the strength of a trend.

# Signal Generation:

# Buy Signal: A buy signal is generated when the SMAs are aligned in a strong uptrend (SMA10 > SMA20 > SMA50 > SMA100 > SMA200), and the ADX is above 20, indicating a strong trend. This condition must hold for at least the last 5 periods.
# Sell Signal: A sell signal is generated when the SMAs are aligned in a strong downtrend (SMA10 < SMA20 < SMA50 < SMA100 < SMA200), and the ADX is above 20. This condition must also hold for at least the last 5 periods
"""

import pandas as pd
import numpy as np

def calculate_atr(high, low, close, n=14):
    high_low = high - low
    high_close = np.abs(high - close.shift())
    low_close = np.abs(low - close.shift())

    true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    atr = true_range.rolling(window=n).mean()
    return atr

def calculate_adx(high, low, close, n=14):
    plus_dm = high.diff()
    minus_dm = low.diff()

    plus_dm = np.where((plus_dm > minus_dm) & (plus_dm > 0), plus_dm, 0.0)
    minus_dm = np.where((minus_dm > plus_dm) & (minus_dm > 0), minus_dm, 0.0)

    atr = calculate_atr(high, low, close, n)

    # Convert to DataFrame to use rolling method
    plus_dm_series = pd.Series(plus_dm, index=high.index)
    minus_dm_series = pd.Series(minus_dm, index=high.index)

    plus_di = 100 * (plus_dm_series.rolling(window=n).sum() / atr)
    minus_di = 100 * (minus_dm_series.rolling(window=n).sum() / atr)

    dx = 100 * np.abs((plus_di - minus_di) / (plus_di + minus_di))
    adx = dx.rolling(window=n).mean()

    return adx, plus_di, minus_di

def generate_signals(data, adx_threshold=20):
    """Generate trading signals based on ADX, +DI, and -DI."""
    signals = np.where(
        (data['+DI'] > data['-DI']) & (data['ADX'] > adx_threshold), 1,
        np.where((data['-DI'] > data['+DI']) & (data['ADX'] > adx_threshold), -1, 0)
    )
    return signals

# Calculate ADX and DI indicators
adx, plus_di, minus_di = calculate_adx(data['high'], data['low'], data['close'])

# Add ADX, +DI, and -DI to DataFrame
data['ADX'] = adx
data['+DI'] = plus_di
data['-DI'] = minus_di

# Generate signals and add them to the DataFrame
data['signals'] = generate_signals(data)

print(data)

"""# This code is designed to calculate the Average Directional Index (ADX) and related indicators (+DI and -DI) for generating trading signals based on the strength and direction of a trend. Here’s a breakdown:

# ATR Calculation: The code begins by calculating the Average True Range (ATR), which measures market volatility. The ATR is derived from the highest of three values: the difference between the high and low prices, the difference between the high price and the previous close, and the difference between the low price and the previous close.

# +DI and -DI Calculation:
# +DI (Positive Directional Indicator) is calculated from the difference between the current high and the previous high.
# -DI (Negative Directional Indicator) is calculated from the difference between the current low and the previous low.
# Both +DI and -DI are then divided by the ATR to normalize them and multiplied by 100 to convert them into percentages.
# ADX Calculation: The code calculates the Directional Movement Index (DX), which compares +DI and -DI. The ADX is the smoothed moving average of the DX values over a specified period (default is 14 periods), and it indicates the strength of a trend without showing its direction.

# Signal Generation:

# Buy Signal (1): Generated when +DI is greater than -DI and the ADX is above a threshold (default is 20), indicating a strong uptrend.
# Sell Signal (-1): Generated when -DI is greater than +DI and the ADX is above the threshold, indicating a strong downtrend.
"""

